# Network

- [OSI 7계층](#OSI-7계층)
- [TCP와 UDP](#TCP와-UDP)
- [3-way handshaking](#3-way-handshaking)
- [4-way handshaking](#4-way-handshaking)
- [로드밸런싱](#로드밸런싱)
- [ARP와 RARP](#ARP와-RARP)
- [HTTP 프로토콜](#HTTP-프로토콜)
- [GET 메서드와 POST 메서드](#GET-메서드와-POST-메서드)
- [SSL](#SSL)
- [쿠키와 세션](#쿠키와-세션)
- [REST와 RESTful의 개념](#REST와-RESTful의-개념)
- [흐름 제어](#흐름-제어)
- [오류 제어](#오류-제어)
- [혼잡 제어](#혼잡-제어)
- [서브넷 마스크](#서브넷-마스크)
- [HTTP 상태 코드](#HTTP-상태-코드)



---



## OSI 7계층

![osi-7-layer](https://user-images.githubusercontent.com/62179353/93036186-1e1ecf00-f67a-11ea-926b-8375074942d0.png)

- 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.
- 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.



### 물리계층

- 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
- 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
- 전송 단위는 Bit이다.

### 데이터링크 계층

- 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다.

- 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다.

- 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.

- 데이터 전송 단위는 Frame이다.

  

### 네트워크 계층

- 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.
- 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션(segmentation/desegmentation), 오류 제어, 인터네트워킹(Internetworking) 등을 수행한다.
- 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.
- 데이터 전송 단위는 Datagram(Packet)이다.



### 전송 계층

- 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
- 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
- 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)이다. (이는 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.)
- 가장 잘 알려진 전송 계층의 예는 TCP이다.
- 데이터 전송 단위는 Segment이다.



### 세션 계층

- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
- 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
- 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다.



### 표현 계층

- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
- MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

### 어플리케이션 계층

- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
- 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.



### **TCP/IP 프로토콜 스택 4계층**

- 네트워크 엑세스 계층
  - OSI 7계층의 물리계층과 데이터 링크 계층에 해당한다. LAN, 패킷망, 등에 사용된다.
-  인터넷 계층
  - OSI 7계층의 네트워크 계층에 해당한다. 통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다. 프로토콜 – IP, ARP, RARP
- 전송 계층
  - OSI 7계층의 전송 계층에 해당한다. 통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.프로토콜 – TCP, UDP
- 응용 계층
  - OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다. TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.



------

## **TCP와 UDP**

전송계층에서 사용되는 통신규약으로서 사용되는 환경에 따라 TCP와 UDP로 나뉘게 된다.

### TCP

- 인터넷 상에서 데이터를 메세지의 형태(**세그먼트** 라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
- TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
- 연결형 서비스로 가상 회선 방식을 제공한다.
  - 3-way handshaking과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
- 흐름제어 및 혼잡제어를 제공한다.
  - **흐름제어**
    - 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
    - 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
  - 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
    - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식이다.
  - 전이중
    - 전송이 양방향으로 동시에 일어날 수 있다.
  - 점대점
    - 각 연결이 정확히 2개의 종단점을 가지고 있다.
  - 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
- 연속성보다 신뢰성있는 전송이 중요할 때에 사용된다.

### UDP

- 데이터를 **데이터그램** 단위로 처리하는 프로토콜이다.

  - 비연결형 서비스로 데이터그램 방식을 제공한다.

    - 연결을 위해 할당되는 논리적인 경로가 없다.
    - 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
    - 이렇게 데이터를 서로 다른 경로로 독립적으로 처리한다.

    

- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.

- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.

- 신뢰성이 낮다.

- TCP보다 속도가 빠르다.

- 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(streaming)에 사용된다.

  

- 참고

  - UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.
  - 또한 같은 모듈(UDP or TCP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우에는 서로 다른 포트 번호를 동적으로 할당한다. (동적할당에 사용되는 포트번호는 49,152~65,535이다.)

  

---



## 3-way handshaking

![3-way-handshaking](https://user-images.githubusercontent.com/62179353/93036611-5377ec80-f67b-11ea-9671-efdcda5db7ea.png)

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 **연결을 설정(Connection Establish)** 하는 과정

- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
- 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
- A 프로세스(Client)가 B 프로세스(Server)에 연결을 요청
  1. A -> B : [**SYN**]
     - 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
     - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
     - **PORT 상태** - B: LISTEN, A: CLOSED
  2. B -> A: [**SYN + ACK**]
     - 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
     - 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
     - **PORT 상태** - B: SYN_RCV, A: CLOSED
  3.  A -> B:  [**ACK**]
     - PORT 상태 - B: SYN_RCV, A: ESTABLISHED
     - 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
     - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
     - **PORT 상태** - B: ESTABLISHED, A: ESTABLISHED



## 4-way handshaking

![4-way-handshaking](https://user-images.githubusercontent.com/62179353/93036615-54a91980-f67b-11ea-9231-f629639fb2c5.png)



- TCP의 **연결을 해제(Connection Termination)** 하는 과정

- A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청
  1. A -> B: [**FIN**]
     - 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
     - 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지
  2. B -> A: [**ACK**]
     - 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다. (이 상태가 TIME_WAIT 상태)
     - 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
     - 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.
  3. B -> A: [**FIN**]
     - 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송
  4. A -> B: [**ACK**]
     - 프로세스 A는 확인했다는 메시지를 전송



- 참고 

  **포트(PORT) 상태 정보**

  - CLOSED: 포트가 닫힌 상태
  - LISTEN: 포트가 열린 상태로 연결 요청 대기 중
  - SYN_RCV: SYNC 요청을 받고 상대방의 응답을 기다리는 중
  - ESTABLISHED: 포트 연결 상태

   

  **플래그 정보**

  - TCP Header에는 CONTROL BIT(플래그 비트, 6bit)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.
    - 즉, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.
  - SYN(Synchronize Sequence Number) / 000010
    - 연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.
  - ACK(Acknowledgement) / 010000
    - 응답 확인. 패킷을 받았다는 것을 의미한다.
    - Acknowledgement Number 필드가 유효한지를 나타낸다.
    - 양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트는 1로 지정된다고 생각할 수 있다.
  - FIN(Finish) / 000001
    - 연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.





- Q. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?
  - A. Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.

#### 

- Q. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
  - A. 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)



- Q. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?
  - A. Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정한다.



---



## 로드밸런싱

가상 IP를 통하여 하나의 서비스를 여러대의 서버가 분산 처리하는 메커니즘을 말한다.

대표적으로 하나의 서버에 발생하는 트래픽이 많을 경우 서버의 부하량과 속도 저하를 해소하거나 하나의 서버에서 장애가 발생하더라도 서비스가 중단되지 않고 지속하기 위해 사용된다.



## ARP와 RARP

ARP(Address Resolution Protocol) 는 OSI 7계층의 네트워크 계층에서 사용되는 주소 결정 프로토콜로서 IP 주소에서 MAC 주소를 알아내기 위한 프로토콜이고,

RARP 은 반대로 MAC 주소에서 IP 주소를 알아내기 위한 프로토콜입니다.

상대방 MAC 주소를 모를 경우 IP와 브로드 캐스팅 네트워크 주소 FFFFFFFFFFFF를 가지는 ARP 패킷을 네트워크 상에 전송하여 이를 수신한 호스트가 자신의 MAC 주소를 반송하는 메커니즘입니다. 이때 ARP 캐시라 불리는 메모리에 테이블 형태로 저장하여, 패킷을 전송할 때에 다시 사용됩니다.



---



## HTTP 프로토콜

- **HTTP 프로토콜**

  - 개념

    - HyperText Transfer Protocol
    - 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜

  - 특징

    - 주로 HTML 문서를 주고받는 데에 쓰인다.

    - TCP와 UDP를 사용하며, **80번 포트**를 사용한다.

    - 1. 비연결(Connectionless)

      - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.

    - 1. 무상태(Stateless)

      - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

- **HTTPS 프로토콜**

  - 개념
    - HyperText Transfer Protocol over Secure Socket Layer
      - 또는 HTTP over TLS, HTTP over SSL, HTTP Secure
    - 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜
  - 특징
    - HTTPS의 기본 TCP/IP 포트로 **443번 포트**를 사용한다.
    - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
      - TLS(Transport Layer Security) 프로토콜은 SSL(Secure Socket Layer) 프로토콜에서 발전한 것이다.
      - 두 프로토콜의 주요 목표는 기밀성(사생활 보호), 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
    - 따라서 데이터의 적절한 보호를 보장한다.
      - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
    - 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관 없는 페이지는 HTTP를 사용한다.

- **HTTPS가 필요한 이유?**

  - 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미지 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
  - 웹 페이지(HTML)는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
  - 이때 주고받는 텍스트 정보에 주민등록번호나 비밀번호와 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
  - 즉, 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.

- **HTTPS의 원리**

  - **[공개키 알고리즘 방식](https://github.com/WeareSoft/tech-interview/blob/master/contents/security.md#대칭키와-비대칭키-차이)**
  - 암호화, 복호화시킬 수 있는 서로 다른 키(공개키, 개인키)를 이용한 암호화 방법
    - 공개키: 모두에게 공개. 공캐키 저장소에 등록
    - 개인키(비공개키): 개인에게만 공개. 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
  - 클라이언트 -> 서버
    - 사용자의 데이터를 **공개키로 암호화** (공개키를 얻은 인증된 사용자)
    - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 **복호화할 수 없음**)
    - 서버의 **개인키를 통해 복호화**하여 요청 처리

- **HTTPS의 장단점**

  - 장점
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
  - 단점
    - 암호화를 하는 과정이 웹 서버에 부하를 준다.
    - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
    - HTTP에 비해 느리다.
    - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
      - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
      - 그러나 HTTPS의 경우에는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.



### Keepalive

두 호스트간 통신이 일정시간 패킷교환이 없을 때 자동으로 연결이 해제되는데 이것을 막기 위해 주기적으로 패킷을 보내는 것

keepalive는 tcp와 http 프로토콜 모두에서 일어날 수 있다.

### TCP에서 Keepalive

일정 시간동안 서로의 패킷 교환이 없을 경우 두 지점간 상대방의 안부를 묻기위해 payload 가 없는 패킷을 주기적으로 보내는 것

종단 시스템 중의 하나가 다운될 때 다른쪽 시스템만 열린 연결 상태를 정리하기 위해 사용

### HTTP에서의 Keepalive

http 는 비연결형 통신이기에 커넥션을 유지하지 않는다. 따라서 재요청시 커넥션을 다시 설정해야되는 비용이 크다.

이것을 해결하기 위해 Keepalive timeout내에 재요청을하면 열려있는 커넥션을 통해 전송하는 구조

### 피기백킹

데이터를 보낼 때 ACK(확인 응답)를 같이 보내는 방식

------

### GET 메서드와 POST 메서드

- HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 전달할 때 사용하는 방식

- GET 메서드 방식

  - 개념
    - 정보를 조회하기 위한 메서드
    - 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드
    - **가져오는 것(Select)**
  - 사용 방법
    - URL의 끝에 '?'가 붙고, 요청 정보가 (key=value)형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
    - 요청 정보가 여러 개일 경우에는 '&'로 구분한다.
    - Ex) `www.urladdress.xyz?name1=value1&name2=value2`
  - 특징
    - URL에 요청 정보를 붙여서 전송한다.
    - URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
      - 한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양은 255자로 제한된다.(HTTP/1.1은 2048자)
    - 요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다.
      - POST 방식보다 보안상 취약하다.
    - HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
      - 즉, Body의 데이터 타입을 표현하는 'Content-Type' 필드도 HTTP Request Header에 들어가지 않는다.
    - POST 방식보다 빠르다.
      - GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.

- POST 메서드 방식

  - 개념

    - 서버의 값이나 상태를 바꾸기 위한 용도의 메서드
    - **수행하는 것(Insert, Update, Delete)**

  - 사용 방법

    - 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.

    - Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.
      - Default: application/octet-stream
      - 단순 txt의 경우: text/plain
      - 파일의 경우: multipart/form-date

  - 특징

    - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
    - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
    - GET 방식보다 보안상 안전하다.

- Q. 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?

  1. 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (Idempotent, 멱등)
     - GET 방식은 가져오는 것(Select)으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.
       - Ex) 게시판의 리스트, 게시글 보기 기능
       - 예외) 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능
     - POST 방식은 수행하는 것으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
       - Ex) 게시판에 글쓰기 기능
  2. 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다.
     - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
     - 즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
     - 이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야한다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.



---



## SSL

응용 계층과 전송 계층 사이에서 동작하는 보안 프로토콜로서 스니핑과 같은 악의적인 행위를 방지하기 위해 만들어진 프로그램 계층이다.  ( RSA의 비대칭키 암호화 시스템을 사용한다.)

### 대칭키

암호를 만드는 행위인 **암호화**를 할 때 사용하는 일종의 비밀번호를 키(key)라고 한다. 

이 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모르면 암호를 푸는 행위인 **복호화**를 할 수 없다.

대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다. 

- 단점 
  - 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다.

### 공개키

두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 

**비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공**한다.

공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 

암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다.

 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 

이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 

공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.



### SSL의 동작 방법

SSL 역시 TCP 프로토콜 기반이라서 Handshake 과정을 거친다.

1. Client는 Server에게 hello 메시지를 보냅니다. Server는 Client에게 Hello 메시지로 응답을 보냅니다. 서로간의 통신을 준비하는 단계로 보면 됩니다.
2. Server는 Client에게 인증서, 사용할 서버키를 교환하며, 인증요청을 보냅니다.
3. Client는 Server에게 인증서, 사용할 클라이언트키를 교환하며, 인증서 확인요청을 합니다.
4. Server, Client 모두 Change Cipher Spec Protocol을 교환하며 위 단계에서 교환한 서버/클라이언트 키, 인증서 등을 토대로 이후의 통신을 지속하겠다는 메시지를 교환하며 서로의 인증을 마칩니다.

### SSL을 사용하지 않는 경우

기본적인 통신 외에 무언가 덧붙여진다는 것은 정보를 보호하는데 도움이 될지언정 속도에는 도움이 되지 않는것이 사실이다.

 보안을 강화하면 편의성이 떨어진다는 것은 어쩔 수 없는 것이다. 암호화를 하기 위해 크고 작은 사전절차를 거쳐야하고, 데이터를 암호화, 복호화 하는 것도 컴퓨터에게는 모두 ‘일’이기 때문이다.

따라서 모든 웹페이지를 암호화해서 HTTPS로 만들면 좋겠지만 그렇게 되면 간단한 페이지를 열어보는 것도 시간이 많이 걸릴 수 있다. 이러한 속도 문제로 인해 단순한 웹 서핑때에는 HTTPS를 사용하지 않고, 로그인이나 결제와 같은 페이지에서 주로 사용한다. 

참고로 일반적인 웹 페이지 HTTP는 TCP 80 포트를 사용하고, SSL이 적용된 HTTPS 페이지는 TCP 443 포트를 사용한다.



---



### 쿠키와 세션

- HTTP 프로토콜의 특징

  - **비연결 지향(Connectionless)**
    - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
  - **상태정보 유지 안 함(Stateless)**
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

- 쿠키와 세션의 필요성

  - HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
  - 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다.
  - 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다.
  - 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다.
  - HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다.

- **쿠키(Cookie)란?**

  - 개념

    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
    - 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
    - 클라이언트의 상태 정보를 브라우저에 저장하여 참조한다.

    

  - 동작 방식

    ![cookie-process](https://user-images.githubusercontent.com/62179353/93043934-44e70080-f68e-11ea-9345-7140b365d8ec.png)

    

    1. 웹브라우저가 서버에 요청

    2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성

    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송

       ```
       Set−Cookie: id=doy
       ```

    4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송

       ```
       cookie: id=doy
       ```

    5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답

  - 쿠키 사용 예

    - 아이디, 비밀번호 저장
    - 쇼핑몰 장바구니

- **세션(Session)이란?**

  - 개념

    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
    - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

  - 동작 방식

    ![session-process](https://user-images.githubusercontent.com/62179353/93043939-46182d80-f68e-11ea-867d-07ce1aeebf75.png)

    1. 웹브라우저가 서버에 요청

    2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함

    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송

       쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장

       ```
       Set−Cookie: JSESSIONID=xslei13f
       ```

    4. 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송

       ```
       Cookie: JSESSIONID=xslei13f
       ```

    5. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답

  - 세션 사용 예

    - 로그인

> 세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다.
> 즉, 상태 정보를 유지하는 수단은 **쿠키** 이다.

- 쿠키와 세션의 차이점
  - 저장 위치
    - 쿠키 : 클라이언트
    - 세션 : 서버
  - 보안
    - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
    - 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
  - 라이프사이클
    - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
    - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
  - 속도
    - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
    - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.



---



### REST와 RESTful의 개념

- **REST**

  - REST의 정의
    - "Representational State Transfer(대표적인 상태 전달)"의 약자
    - 월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
      - REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
      - REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.
  - REST의 구체적인 개념
    - HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(Post, Get, Put, Delete)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
      - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
      - 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.
  - REST 장단점
    - 장점
      - 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해준다.
      - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
      - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
    - 단점
      - 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
      - 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
        - PUT, DELETE를 사용하지 못하는 점
        - pushState를 지원하지 않는 점
  - REST가 필요한 이유
    - '애플리케이션 분리 및 통합'
    - '다양한 클라이언트의 등장'
    - 즉, 최근의 서버 프로그램은 다양한 브라우저와 안드로이폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
  - REST 구성 요소
    1. 자원(Resource): URI
       - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
       - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP **URI** 다.
       - Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.
    2. 행위(Verb): HTTP Method
       - HTTP 프로토콜의 Method를 사용한다.
       - HTTP 프로토콜은 **GET, POST, PUT, DELETE, HEAD** 와 같은 메서드를 제공한다.
    3. 표현(Representation of Resource)
       - Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
       - REST에서 하나의 자원은 **JSON, XML, TEXT, RSS** 등 여러 형태의 Representation으로 나타내어 질 수 있다.
       - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.
  - REST 특징
    1. Server-Client(서버-클라이언트 구조)
    2. Stateless(무상태)
    3. Cacheable(캐시 처리 가능)
    4. Layered System(계층화)
    5. Code-On-Demand(optional)
    6. Uniform Interface(인터페이스 일관성)

- **REST API**

  - REST API의 정의

    - REST 기반으로 서비스 API를 구현한 것
    - 최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.

  - REST API의 특징

    - 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
    - REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
    - 즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.

  - REST API 설계

    기본 규칙

    1. URI는 정보의 자원을 표현해야 한다.
       - resource는 동사보다는 명사를 사용한다.
       - resource는 영어 소문자 복수형을 사용하여 표현한다.
       - Ex) `GET /Member/1` -> `GET /members/1`
    2. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.
       - URI에 HTTP Method가 들어가면 안된다.
       - Ex) `GET /members/delete/1` -> `DELETE /members/1`
       - URI에 행위에 대한 동사 표현이 들어가면 안된다.
       - Ex) `GET /members/show/1` -> `GET /members/1`
       - Ex) `GET /members/insert/2` -> `POST /members/2`

  - REST API 설계 규칙

    1. 슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.
       - Ex) `http://restapi.example.com/houses/apartments`
    2. URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
       - URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
       - REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
       - Ex) `http://restapi.example.com/houses/apartments/ (X)`
    3. 하이픈(- )은 URI 가독성을 높이는데 사용
       - 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.
    4. 밑줄(_ )은 URI에 사용하지 않는다.
       - 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.
    5. URI 경로에는 소문자가 적합하다.
       - URI 경로에 대문자 사용은 피하도록 한다.
       - RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문
    6. 파일확장자는 URI에 포함하지 않는다.
       - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
       - Accept header를 사용한다.
       - Ex) `http://restapi.example.com/members/soccer/345/photo.jpg (X)`
       - Ex) `GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)`
    7. 리소스 간에는 연관 관계가 있는 경우
       - /리소스명/리소스 ID/관계가 있는 다른 리소스명
       - Ex) `GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)`
    8. :id는 하나의 특정 resource를 나타내는 고유값
       - Ex) student를 생성하는 route: POST /students
       - Ex) id=12인 student를 삭제하는 route: DELETE /students/12

- **RESTful**

  - RESTful의 개념

    - RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
      - 즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.
    - RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다.

  - RESTful의 목적

    - 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
    - RESTful API를 구현하는 근본적인 목적이 퍼포먼스 향상에 있는게 아니라, 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는게 주 동기이니, 퍼포먼스가 중요한 상황에서는 굳이 RESTful API를 구현할 필요는 없다.

  - RESTful 하지 못한 경우

    - Ex1) CRUD 기능을 모두 POST로만 처리하는 API
    - Ex2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)

    

## 흐름 제어

TCP가 신뢰성 보장을 위해 사용하는 메커니즘 중 하나로서 송신측과 수신측의 속도 차이를 해결하기 위해 사용하는 메커니즘

- 대표적으로 **Stop and Wait ARQ, Sliding Window**

### Stop and Wait

매번 패킷을 보내고 난 후 확인 응답을 받아야만 패킷을 전송하는 방식

### Sliding Window

수신측에서 설정한 윈도우 크기만큼 확인 없이 세그먼트를 전송할도록 하여 `window size`을 동적으로 조절하는 방식

#### Window란

데이터를 보내기 전 3-way-handshaking 을 통해 수신측이 데이터를 받을 수 있는 버퍼양과 송신측이 데이터를 보낼 양을 맞추게 되는데 이 데이터 양을 window size라고 합니다.



## 오류 제어

### Stop and Wait ARQ

매번 패킷을 보내고 난 후 확인 응답을 받아야만 패킷을 전송하는 방식

### Go-Back-N ARQ

누적 응답을 사용한 방식으로 응답신호가 손실되더라도 이후 순서의 응답신호를 받으면 window가 shift 된다. 

timer가 하나이기에 순서가 낮은 프레임이 손실되면 이후의 모든 프레임을 재전송한다.

수신측의 window 사이즈가 1로 설정되어 있어 프레임을 순차적으로만 수신할 수 있다.

### Selective Repeat ARQ

선택 응답을 사용한 방식으로 window의 가장 처음 프레임의 응답신호를 받아야 window가 shift 된다.

각 프레임당 timer가 동작하고 순서가 낮은 프레임이 손실되더라도 해당 프레임만 재전송한다.

 송신측과 수신측의 window size가 같기에 수신측에서 프레임 순서와 상관없이 수신이 가능하다.



## 혼잡 제어

TCP가 신뢰성 보장을 위해 사용하는 메커니즘 중 하나로서 네트워크의 혼잡을 피하기 위해 송신자의 전송속도를 줄이기 위해 사용하는 메커니즘

- 대표적으로 AIMD, Slow Start, Fast Retransmit, Fast Recovery 기법





## 서브넷 마스크

네트워크 관리자가 네트워크 성능을 향상시키기 위해, 자원을 효율적으로 분배하기 위해 네트워크 영역과 호스트 영역을 분할 하는 것입니다.

A~E 클래스까지 규모별로 나뉘어 있습니다.

![subnet-mask](https://user-images.githubusercontent.com/62179353/93044411-c3906d80-f68f-11ea-8381-3b2b712c84da.png)

## HTTP 상태 코드

<img width="740" alt="http-status-code" src="https://user-images.githubusercontent.com/62179353/93044407-becbb980-f68f-11ea-9578-17740c090327.png">

