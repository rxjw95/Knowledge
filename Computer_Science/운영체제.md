# 운영체제

- [시스템 소프트웨어](#시스템 소프트웨어)
- [운영체제](#운영체제)
- [운영체제 운용 기법](#운영체제 운용 기법)
- [컴파일러와 인터프리터](#컴파일러와 인터프리터)
- [링커와 로더](#링커와 로더)
- [인터럽트](#인터럽트)
- [프로세스](#프로세스)
- [스레드](#스레드)
- [스케줄링](#스케줄링)
- [스케줄링 기법](#스케줄링 기법)
- [병행 제어](#병행 제어)
- [동기화 기법](#동기화 기법)
- [교착 상태](#교착 상태)
- [Thread safe](#Thread safe)
- [메모리 구조](#메모리 구조)
- [가상 메모리](#가상 메모리)
- [Paging과 Segmentation](#Paging과 Segmentation)
- [단편화](#단편화)
- [메모리 배치 전략](#메모리 배치 전략)
- [페이지 교체 전략](#페이지 교체 전략)
- [Page fault](#Page fault)
- [Thrashing](#Thrashing)
- [Locality](#Locality)
- [Working Set](#Working Set)
- [동기와 비동기](#동기와 비동기)



---



## 시스템 소프트웨어

- 컴퓨터 시스템 전체를 작동시키는 프로그램
- 프로그램을 메모리에 적재시키너나, 인터럽트 관리, 장치 관리, 언어 번역 등의 기능을 담당
- 가장 대표적으로 **운영체제**가 있고, 언어 번역 프로그램, 링커, 로더 등이 있다.



## 운영체제

- 컴퓨터 시스템의 **모든 자원**들을 효율적으로 관리한다.
- 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공한다.

> 모든 자원이란, **프로세서, 기억장치, 입출력장치, 파일 및 정보 등**의 컴퓨터 시스템이 동작하고 상호작용하기 위해 필요한 모든 자원을 의미한다.



### 운영체제의 목적

- 시스템 성능 향상, 사용성 향상, 신뢰도 향상에 목적이 있다.

- 기준

  1. 처리능력(Throughput) : 일정 시간 내에 시스템이 처리하는 일의 양
  2. 반환 시간(Turn Around Time) : 작업 의뢰 시간부터 처리 완료 시간까지의 시간
  3. 사용 가능도(Availability) : 사용 가능한 정도..?
  4. 신뢰도(Reliability) : 문제를 정확하게 해결하는 정도

  





## 운영체제 운용 기법

### 일괄처리 시스템

- 일정량 혹은 일정 시간 동안 데이터를 모아서 한꺼번에 처리하는 방식

- 반환 시간이 늦지만 CPU 유휴 시간이 줄어든다.

- 급여 계산, 연말 결산 등의 업무에서 사용

  

### 멀티 프로그래밍 시스템(Multi-Programming)

- 하나의 CPU와 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
- CPU 사용률과 처리량이 증가한다.



### 멀티 프로세싱 시스템(Multi-Processing)

- 여러개의 CPU와 하나의 주기억장치를 이용해서 여러 개의 프로그램을 동시에 처리하는 방식
- 신뢰성과 안정성이 높다.
- 하나의 메모리를 공유해야되기 때문에 자원 공유 문제를 잘 처리해야한다.



### 시분할 시스템

- 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리
- 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 준다.
- 라운드 로빈 방식





## 컴파일러와 인터프리터

### 기계어와 어셈블리어(저급 언어)

- 기계어는 컴퓨터가 직접 이해할 수 있는 언어이다.
- 어셈블리어는 기계어와 1:1로 대응되는 기호로 이루어진 언어, 어셈블러에 의해 해석된다.
- 두 언어 모두 호환성이 없다. 컴퓨터 기종마다 기계어가 다르기 때문



### 컴파일러

- 고급 언어로 작성된 **프로그램 전체를 목적 프로그램으로 번역**한다.
- **링킹 작업 후에 실행 가능한 실행 프로그램을 생성**한다.
- 전체 번역 과정에서 시간이 걸리지만, 한번 번역하면 다시 번역할일 없어서 실행이 빠르다.
- 포틀란, 코볼, 파스칼, C/C++, PL/1 등이 있다.



### 인터프리터

- 고급 언어로 작성된 **프로그램을 한 줄 단위로 번역**한다.
- 번역과 동시에 프로그램을 **한 줄 단위로 즉시 실행**시킨다.
- 목적 프로그램이 생성되지 않는다.
- 시분할 시스템에 유용하고 변화에 대한 반응이 빠르다.
- 번역 속도는 빠르지만, 실행 시 매번 번역해야 해서 실행은 느리다.
- 베이직, LISP, APL 등이 있다.





## 링커와 로더

- 링커 : 컴파일러에 의해 생성된 목적 프로그램과 그 외에 프로그램 동작을 위한 라이브러리와 프로그램을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어



- 로더 : 컴퓨터 내부로 정보를 들여오거나 로드 모듈(링커에 의해 만들어진)을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어



### 로더의 기능

- 할당 : 메모리 내에 적재할 공간을 확보
- 연결 : 부 프로그램 호출 시 그 부프로그램이 할당된 시작주소를 호출부에 연결
- 재배치 : 보조기억장치에 저장된 프로그램이 사용되는 각 주소들을 실제 주소로 배치
- 적재 : 실행 프로그램을 메모리에 실제로 옮기는 기능
- 위 과정을 차례로 수행하지만, 컴파일러 혹은 링커가 대신 수행하는 경우도 있다.



### 로더의 종류

1. Compile And Go 로더 : 별도 로더 없이 컴파일러가 로더의 기능 수행
2. 절대 로더 : 4개의 기능중 적재 기능만 수행하는 로더
3. 직접 연결 로더 : 4개의 기능을 모두 수행하는 로더
4. 동적 적재 로더 : 프로그램을 한꺼번에 적재하는 것이 아닌 실행 시 필요한 블록만 적재
   - Load on Call 이라고 부른다.



## 인터럽트

- CPU가 특정 프로그램을 처리하고 있는 도중에 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.



### 인터럽트 종류

H/W 인터럽트 : 하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생시킨다.

S/W 인터럽트 : 소프트웨어가 발생시키는 인터럽트이다. 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다.
						   Exception, System Call



### 처리 순서

1. 인터럽트 발생

2. CPU는 현재 처리 중인 명령어를 완료한다.

3. 현재까지 수행중이었던 process 상태를 **PCB(Process Control Block)**에 저장한다. (수행중이던 MEMORY주소, 레지스터 값, 하드웨어 상태 등...)

4. PC(Program Counter)에 다음에 실행할 명령의 주소를 저장한다.

5. 인터럽트 벡터를 읽고 ISR 주소값을 얻어 **ISR(Interrupt Service Routine)**로 점프하여 루틴을 실행한다.

6. 발생한 인터럽트에 맞는 서비스 루틴을 실행한다.

7. 인터럽트를 처리하면, 백업해둔 레지스터과 PC 값을 복원하여 기존의 실행 위치로 복원한다.





## 프로세스

- 실행중인 프로그램
- 메모리에 적재된 프로그램
- 운영체제가 관리하는 실행 단위



### PCB(Process Control Block)

- 운영체제가 프로세스에 대한 중요 정보를 저장해놓은 블록
- 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 제거된다.
- PCB에 저장된 정보는 다음과 같다.
  - 프로세스 상태(준비, 대기, 실행 등)
  - 포인터(부모 프로세스 포인터, 자식 프로세스 포인터, 할당 자원 포인터 등)
  - 고유 번호
  - 우선순위
  - CPU 레지스터, 주기억장치 관리, 입출력 상태, 계정 정보



### 프로세스 상태 전이

![process_status](C:\Users\RyuJangwook\Desktop\git_local\Knowledge\Image_Resource\process_status.png)

- 제출 : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- 접수 : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
- **준비**
  - 프로세스가 CPU를 할당받기 위해 기다리는 상태
  - 프로세스는 준비상태 큐에서 들어가있는 상태
  - 접수 상태에서 준비 상태로의 전이는 **잡 스케줄러**에 의해 수행
- **실행**
  - 준비상태 큐에 있는 프로세스가 CPU를 할당받아 실행되는 상태
  - 프로세스 수행이 완료되기 전에 주어진 할당 시간이 초과되면 다시 준비 상태로 전이
  - 프로세스에 입출력 처리가 필요하면 대기 상태로 전이
  - 준비 상태에서 실행 상태로의 전이는 CPU 스케줄러에 의해 수행 - Dispatch
- **대기** : 프로세스의 입출력 처리가 완료될 때까지 대기하고 있는 상태
- 종료 : 프로세스의 실행이 끝나고 할당이 해제된 상태





## 스레드

- 프로세스 내에서의 작업 단위
- 프로세스의 일부 특징을 갖고 있기 때문에 경량 프로세스라고도 한다.
- 독립적인 스케줄링의 최소 단위



### 특징

- 각자의 `stack` 영역을 보유하고 프로세스의 `code`, `data`, `heap` 영역을 공유한다.
- 공유 자원에 대한 동기화를 적절히 제어해야 한다.
- 프로세스의 디스패치 시간보다 빠르기 때문에 속도면에서 효율적이다.
- 운영체제의 도움없이 통신이 가능하다.



### 분류

- **사용자 수준 스레드**

  장점 : 사용자 수준 스레드는 context switch가 없다. 따라서 커널 스레드보다 오버헤드가 적다.

  단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간 나머지 스레드들도 전부 정지됨. 이는 커널이 스레드의 존재를 알지 못하기에 발생하는 현상임.

  

- **커널 수준 스레드**

  장점 : 사용자 수준 스레드보다 효율적이다. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있는 장점이 있다.

  단점 : 커널 스케줄러를 통해 context switch가 발생한다. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 빈번할 수록 성능이 하락한다.



### 멀티 프로세스보다 멀티 스레드가 가지는 이점

- 병행성 증진
- 프로그램 처리율 향상
- **프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소**함으로서 **자원을 효율적으로 관리**할 수 있다는 점이다. (Context Switch 비용 감소)
- **프로세스 간 통신(IPC)보다 스레드 간의 통신 비용이 더 적게 발생**한다. (Stack 영역을 제외한 나머지 자원들을 공유하기 때문)



> 멀티 스레드 사용 시에는 공유 자원으로 인한 문제를 해결하기 위해 동기화를 신경써 주어야 한다.





## 스케줄링

- 프로세스가 생성되어 실행될 때 적절한 프로세스에게 자원을 할당하는 작업



### 분류

- 장기 스케줄링 : 프로세스를 준비상태 큐로 보내는 작업 (작업 스케줄러)
- 중기 스케줄링 : 어떤 프로세스가 CPU를 할당받을 것인지 결정하는 작업
- 단기 스케줄링 : 프로세스가 실행되기 위해 CPU를 할당받는 시기와 지정하는 작업



### Context Switch

- 스케줄링으로 인해 프로세스가 교체되는 과정에서 기존 CPU의 할당을 받은 프로세스 상태를 저장하고 새로운 프로세스의 상태 정보를 불러와 CPU를 할당시키는 것



### 스케줄링 목적

- 공정성
- 처리율 증가
- CPU 이용률 증가



## 스케줄링 기법

### 비선점 스케줄링

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗을 수 없는 스케줄링 기법
- 즉, CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용
- 중요한 작업이 중요하지 않은 작업을 기다리는 경우 발생
- 일괄 처리 방식에 적합



**FCFS(First Come First Service) = FIFO**

- 도착한 프로세스에 따라 차례로 CPU를 할당하는 기법
- 중요한 작업이 오래 대기해야하는 상황이 발생

**SJF(Shortest Job First)**

- 준비상태 큐에 있는 프로세스중 실행 시간이 가장 짧은 프로세스에게 CPU를 할당하는 기법
- 실행 시간이 긴 프로세스는 무기한 연기 상태가 될 수 있음

**HRN(Highest Response-ratio Next)**

- SJF 보완, 대기 시간과 실행 시간을 이용하여 우선순위를 매기는 기법
- 우선 순위 = (실행 시간 + 대기 시간) / 실행 시간

**Priority**

- 각 프로세스마다 우선순위를 부여하여 가장 높은 우선순위의 프로세스에게 CPU 할당하는 기법
- 우선순위가 동일할 경우 FCFS 와 같다.
- 가장 낮은 우선순위를 부여받은 프로세스는 무한 연기 상태가 된다.
  - Aging 기법



### 선점 스케줄링

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 다른 우선순위가 높은 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
- 많은 오버헤드 초래
- 선점시키기 위해 인터럽트용 타이머 클록이 필요
- 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.

**SRT(Shortest Remain Time)**

- 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 가진 프로세스에게 CPU를 할당하는 기법
- 각 프로세스의 실행 시간을 추적하고 보유해야하는 말도 안되는 기법)

**RR(Round Robin)**

- 각 프로세스에게 시간 할당량(Time Slice)을 부여하여 그 사이에 실행이 완료되지 않으면 다음 프로세스에게 CPU를 할당하고 준비 상태 큐의 맨 뒤로 배치시키는 기법
- 시간 할당량이 커지면 FCFS와 같아지고 시간 할당량이 작아지면 많은 오버헤드를 초래한다.

**MQ(Multi-Level Queue)**

- FCFS와 RR 혼합, 프로세스를 특정 그룹으로 분류하여 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법
- 각 준비 상태 큐에 있는 작업들은 다른 준비 상태 큐로 이동하지 못한다.

**MFQ(Multi-Level Feedback Queue)**

- MQ를 보완, 각 준비 상태 큐에 있는 작업들은 다음 단계의 준비 상태 큐로 이동시키는 기법





## 병행 제어

### 임계 구역

- 다중 프로그래밍 운영체제에서 여러 개의 프로세스가 공유하는 데이터 및 자원에 대하여 어느 한 시점에서는 **하나의 프로세스만 자원을 사용하도록 지정된 공유 영역**을 의미한다.



### 상호 배제

- 특정 프로세스가 공유 자원을 사용하고 있는 경우 다른 프로세스가 해당 자원을 사용하지 못하도록 제어하는 기법
- 소프트웨어적 기법
  - 두 개의 프로세스 기준 : 데커 알고리즘, 피터슨 알고리즘
  - 여러 개의 프로세스 기준 : 빵집 알고리즘
- 하드웨어적 기법
  - Test&Set 기법과 Swap 명령어 기법



## 동기화 기법

- 두 개 이상의 프로세스를 한 시점에 동시에 처리할 수 없으므로 각 프로세스에 대한 처리 순서를 결정하는 것으로, 상호 배제의 한 형태



### 뮤텍스와 세마포

- 정의 : **여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법**



### 뮤텍스

- 오직 1개만의 프로세스(혹은 스레드)를 임계영역에 접근시키는 방법

- 임계영역에 진입하면 `lock`을 걸어 다른 프로세스(혹은 스레드)가 접근하지 못하도록 하고, 임계영역에서 탈출하면 `unlock`으로 임계영역 접근을 허용한다.



### 세마포

- 세마포라는 정수 값을 가진 변수를 활용하여 자원 접근의 허용치를 설정해서 **여러 프로세스(혹은 스레드)를 임계영역에 접근시키는 방법**
- 하나의 프로세스만을 접근시키도록 하는 이진 세마포와 여러 프로세스를 접근시키도록 하는 카운트 세마포가 있다.
- `wait` 동작을 통해 세마포 값을 줄인다.(세마포가 0이 되면 임계 영역에 접근할 수 없다.)
- `signal`동작을 통해 세마포 값을 늘린다.(자원의 반납)



### 모니터

- 라이브러리를 이용한 프로그램 기법으로 프로세스에게 할당하는 데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성된다. (Syncronized 키워드)
- 모니터 내의 공유 자원을 사용하려면 프로세스는 반드시 모니터의 진입부를 호출해야한다..
- 한 순간에 하나의 프로세스만 진입할 수 있다.
- Wait과 Signal 연산이 사용된다.



## 교착 상태

- 상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 정뮤한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 무한정 기다리는 현상



### 필요 충분 조건

1. 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없다.
4. 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.



### 교착 상태 해결 방법

**예방 기법**

- 교착 상태의 필요 충분 조건 중 한가지를 제거(부정)한다.
- 자원 낭비가 가장 심함

**회피 기법**

- 교착 상태가 발생할 가능성을 파악하고 적절히 피해나가는 방법
- 은행원 알고리즘

**발견 기법**

- 시스템을 지속적으로 점검하며 교착 상태에 있는 프로세스와 자원을 해제 한다. (자원 할당 그래프, 교착 상태 발견 알고리즘)

**회복 기법**

- 교착상태를 일으킨 프로세스를 종료하거나 할당된 자원을 선점시켜 프로세스나 자원을 회복한다.



## Thread-safe

- 멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한 대로 동작하는 것을 말한다.(이러한 상황을 "Thead-safe하다" 라고 표현한다.)

  

- Thread-safe하게 구현하기

  - Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 상호 배제해야한다.
  - Mutex나 Semaphore 등이 있다.

  

- **Reentrant**

  - Reentrant는 **재진입성**이라는 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 **동시에 접근해도 언제나 같은 실행 결과**를 보장한다는 의미이다.
  - 이를 만족하기 위해서 **해당 서브루틴에서는 공유자원을 사용하지 않으면 된다.**
    - 예를들어 정적(전역) 변수를 사용하거나 반환하면 안 되고 호출 시 제공된 매개변수만으로 동작해야한다.
  - 따라서, Reentrant하다면 Thread-safe하지만 그 역은 성립하지 않는다.



## 메모리의 구조

![memory_structure](C:\Users\RyuJangwook\Desktop\git_local\Knowledge\Image_Resource\memory_structure.png)

메모리는 크게 코드, 데이터, 스택, 힙 영역으로 나누어져 있다.

- 코드 영역은 실행될 프로그램의 코드가 저장되어 있는 영역이다.
- 데이터 영역은 전역 변수가 저장되어 있는 영역이다.
- 스택 영역은 지역변수와 매개 변수가 저장되어 있으며, 함수의 호출과 함께 할당되는 영역이다.
- 힙 영역은 사용자에 의해 동적으로 할당되고 해제될 수 있는 메모리 영역이다.



## 가상 메모리

- 가상 메모리는 멀티 프로세스 환경에서 프로세스마다 충분한 메모리를 할당하기에 물리 메모리의 한계가 있어서 보조기억장치의 일부를 주기억장치처럼 사용하는 개념

- 프로세스마다 가상 주소를 부여하고 맵핑 테이블을 통해 물리 주소로 변환해서 데이터를 `read&write`한다.



## Paging과 Segmentation

- 페이지 기법 : 가상 메모리를 같은 크기의 페이지라는 단위로 블록을 나누고, 물리 메모리를 같은 크기의 프레임이라는 단위로 블록을 나누어 **사용하지 않는 프레임을 페이지에 옮기고 필요한 데이터를 페이지 단위로 프레임에 옮기는 기법**이다. (내부 단편화 존재, 외부 단편화 해결)

  > 이때 페이지와 프레임을 매핑 시키기 위해 **Paging Table**을 사용한다.

  

- 세그멘테이션: 페이지와 같은 개념이지만 가상 메모리와 물리 메모리를 같은 크기로 분할하는 것이 아닌 가변적으로 분할하는 기법입니다. (내부 단편화 해결, 외부 단편화 존재)

  > 이때 세그먼트와 프레임을 매핑 시키기 위해 **Segmentation Table**을 사용한다.



## 단편화

- 내부 단편화(internal fragmentation) : 작업에 필요한 공간보다 많은 공간을 할당받음으로서 발생하는 내부의 사용 불가능한 공간

- 외부 단편화(external fragmentation) : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우(메모리 배치에 따라 생기는 문제)



## 메모리 배치 전략

- First fit : 메모리 공간을 처음부터 검사하며 프로그램이 들어갈 수 있는 첫번째 메모리 영역에 할당한다.

- Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작하여 공간을 찾는다.

- Best fit : 모든 메모리 공간을 검사해서 내부 단편화가 최소가 되는 공간에 할당한다.

- Worst fit : 모든 메모리 공간을 검사해 내부 단편화가 최대가 되는 공간에 할당한다.



## 페이지 교체 전략

OPT(Optimal replacement) : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법. 예측이 필요하여 실현 가능성이 희박함.

FIFO : 메모리가 할당된 순서대로 페이지를 교체 - 벨로이디의 모순 현상(프레임 수를 증가시켰는데도 불구하고 페이지 부재(Page fault) 가 증가하는 현상)

LRU(Least Recently used) : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체, 계수기 스택이 필요.

LFU(Least Frequently used) : 사용 빈도가 가장 적은 페이지를 교체

NUR(Not Used Recently) : 최근에 사용하지 않은 페이지를 교체하며 최근 사용 여부를 참조 비트와 변형 비트를 두어 페이지 교체 우선순위를 결정한다.



## Page fault

가상 메모리 사용되는 개념으로 페이지 테이블에 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 경우를 페이지 폴트라고 한다.

페이지 폴트가 발생하면 프레임을 새로 할당 받아야 하며,  그리고 페이지 테이블을 재구성 하고, 프로세스의 작업을 재시작한다.



## **Thrashing**

스래싱이란 너무 빈번히 페이지 부재가 일어나는 현상을 말하는 것으로, 과도하게 페이지 부재가 발생하면 프로세스 수행에 소요되는 시간보다 페이지 이동에 소요되는 시간이 더 커지므로 CPU 효율이 나빠진다. 따라서 스래싱은 심각한 시스템의 성능 저하를 초래하게 된다.



## Locality

프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질

- **시간 구역성(Temporal Locality)**

  - 처음에 참조된 기억 장소가 가까운 미래에도 계속 참조될 가능성이 높음

- **공간 구역성(Spatial Locality)**

  - 어떤 기억 장소 하나가 참조되었을 때, 그 근처의 기억 장소가 계속 참조될 가능성이 높음

    

## Working Set

워킹 세트는 가상 기억 장치 시스템에서 실행중인 프로세스가 일정 시간 동안에 참조하는 페이지의 집합을 말하는 것으로, 각 프로세스에게 할당해야할 최소한의 페이지 프레임 수를 결정함으로써 스래싱을 방지할 수 있는 기법이다.



## 동기와 비동기

동기는 요청을 보낸 후 반드시 그 요청에 대해 응답을 받아야지만 다음 동작을 실행한다.

비동기는 요청을 보낸 후 응답에 상관없이 다음 동작을 실행할 수 있다. 그렇기 때문에 어떤 요청에 대한 응답인지에 대한 확인이 필요하며 설계 방식이 더 복잡하다.